<!DOCTYPE html>
<html lang="en">
<style>
    #path .active{
        fill: orange;
    }
</style>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/flubber@0.3.0"></script>
</head>
<body>
    <div id="mapcontainer" class="svg-container"></div>
    <script>
        var block = false;
        var w = 1400;
        var h = 700;
        var centered;
        var svg = d3.select("#mapcontainer")
            .append("svg")
           // .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", "0 0 " + w + " " + h)
            .style("background", "#c9e8fd")
         //   .classed("svg-content", true);

        var projection = d3.geoMercator()
            .translate([w/2, h/2])
            .scale(175)
            .center([0,40]);

        var path = d3.geoPath().projection(projection);

        var worldmap = d3.json("lowpolymap.geojson");

        var data = d3.json("datafixed.json");

        var grid = d3.json("mygrid.json");

        var arr = [];

        for(let i =0; i<=31; i++){
            arr.push(i)
        }
        var xscale = d3.scaleBand(arr, [0 , w])
            .padding(.1);


        var arr2 = [];

        for(let i =0; i<25; i++){
            arr2.push(i)
        }
        var yscale = d3.scaleBand()
            .domain(arr2)
            .range([0 , h])
            .padding(.1);

        var colorscale = d3.scaleSequential([0,8], d3.interpolateViridis)
            .nice();

            Promise.all([worldmap, grid, data]).then(function (values) {

            svg.selectAll("path")
                .data(values[0].features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill",  function (d) {
                    let name = d.properties.NAME_ENGL;
                    let retname = values[2].find(d => d.Country === name);
                    if(retname != null){
                        return colorscale(retname.Happiness_score)
                    }
                    return "red";
                })
                .attr("stroke", "black")
                .style('opacity', 0.8)
                .style('stroke-width',0.3)
                .on('mouseover',function(d){
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke-width', 3);
                })
                .on('mouseout', function(d){
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke-width',0.3);
                })
                .on('click', function (d) {
                    console.log(d);
                    var x, y, k, xbox, ybox;
                    var xh = xscale.bandwidth();
                    var yh = yscale.bandwidth();

                    var country = d.properties.ISO3_CODE;

                    var gridcountry  = values[1].find(d => d.code === country);


                    if(gridcountry != null){
                        xbox = xscale(gridcountry.x);
                        ybox = yscale(gridcountry.y);
                    }
                    else{
                        var cen = path.centroid(d);
                        xbox = cen[0];
                        ybox = cen[0]
                    }

                    if (d && centered !== d) {
                        var centroid = path.centroid(d);
                        x = xbox;
                        console.log(x);
                        y = ybox;
                        console.log(y);
                        k = 4;
                        centered = d;
                    } else {
                        x = w /2;
                        y = h /2;
                        k = 1;
                        centered = null;
                    }
                    svg.selectAll("path")
                        .attr("stroke", "black")
                        .style("stroke-width", 0.3)


                    if(d && centered == d){
                        d3.select(this)
                            .attr("stroke", "orange")
                            .style('stroke-width', 3);
                    }

                    svg.selectAll("path")
                        .classed("active", centered && function(d) { return d === centered; });

                    svg.transition()
                        .duration(750)
                        .attr("transform", "scale(" + k + ")translate(" + w /2+ "," + h /2+ ")translate(" + -x  + "," + -y + ")")
                        .style("stroke-width", 1.5 / k + "px");
                    if (!block) {
                        //svg.selectAll("path")
                        d3.select(this)
                            .transition()
                            .duration(3000)
                            .attrTween('d', d => {
                                let country = d.properties.ISO3_CODE;
                                let gridcountry  = values[1].find(d => d.code === country);

                                let x = xscale(gridcountry.x);
                                let y = yscale(gridcountry.y);

                                var filteredPolygons = d.geometry.coordinates.map( coordinates => path({type: 'Polygon', coordinates: coordinates}));
                                var square = [[x,y], [x+xh,y], [x+xh,y+yh], [x,y+yh], [x,y]];
                                console.log(country)
                                console.log(gridcountry)
                                console.log(filteredPolygons)
                                console.log(square)
                               return flubber.combine(filteredPolygons, square, { single: true });
                            });
                        block = true;
                    } else {
                        if (centered == null){
                            console.log(d);

                            //svg.selectAll("path")
                            d3.select(this)
                                .transition()
                                .duration(3000)
                                .attrTween('d', d => {
                                    let country = d.properties.ISO3_CODE;
                                    let gridcountry  = values[1].find(d => d.code === country);

                                    let x = xscale(gridcountry.x);
                                    let y = yscale(gridcountry.y);

                                    var square = [[x, y], [x + xh, y], [x + xh, y + yh], [x, y + yh], [x, y]];
                                    var filteredPolygons = d.geometry.coordinates.map(coordinates => path({
                                        type: 'Polygon',
                                        coordinates: coordinates
                                    }));
                         //           return flubber.separate(square, filteredPolygons, {single: true});
                                })
                                .attr("stroke", "black");

                            block = false;
                        }


                    }

                })

        });

    </script>
</body>
</html>